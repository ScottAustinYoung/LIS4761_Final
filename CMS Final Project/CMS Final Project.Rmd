---
title: "CMS Final Project"
author:
  - Christopher Reddish
  - Khushi Patel
  - Naomi Vaid
  - Sneh Patel
  - Scott Young
  - Steven Barden
date: "04/27/2025"
output: 
  html_document:
    toc: true
    toc_float: true
    numbered_sections: true
    theme: readable
---

# Introduction
This project analyzes Medicare provider data for the Tampa Bay region to understand service patterns, cost structures, and geopgraphic distributions. We utilize association rule mining, k-means clustering, linear regression, and geospatial visualization to explore relationships within the data. The primary data source is the CMS Medicare Provider Utilization and Payment Data Public Use File. Our goal is to identify key trends and factors influencing healthcare delivery and costs in this specific geographic area.

# Setup: Loading Libraries and Data
## Load Required Libraries
```{r, "Libraries"}
# Add your library below.
# List of required packages
required_packages <- c(
  "tidyverse",
  "GGally",
  "ggplot2",
  "sf",
  "dplyr",
  "readr",
  "arules",
  "leaflet",
  "tigris",
  "scales",
  "htmlwidgets",
  "jsonlite",
  "purrr",
  "stringr",
  "lme4",
  "broom.mixed"
)

# Install any packages that are not already installed
to_install <- setdiff(required_packages, rownames(installed.packages()))
if (length(to_install) > 0) {
  install.packages(to_install, dependencies = TRUE)
}

# Load all required packages and check if successfully loaded
for (pkg in required_packages) {
  if (!require(pkg, character.only = TRUE)) {
    warning(sprintf("Package '%s' could not be loaded.", pkg))
  }
}

# Enable caching for tigris package
options(tigris_use_cache = TRUE)

```

# Cleaning the dataset: Sneh Patel, Steven Barden, Christopher Reddish, and Scott Young
1. Assigning Tampa Bay regional ZIP codes to a variable.
2. Reading in the initial dataset.
3. Adjusting misinputs on the initial dataset.
4. Filter the data by Tampa Bay ZIP codes.
5. Renaming the columns.
6. Writing the dataset to a usable .csv.
7. Printing where the file was written to.
```{r, "Step 1"}
## Step 1.1
# Tampa Bay ZIP codes
tampa_bay_zips <- as.numeric(c(
  "34423","34428","34429","34430","34431","34432","34433","34434","34436","34442","34445",
  "34446","34447","34448","34449","34450","34451","34452","34453","34461","34465","34601","34602","34604","34605",
  "34606","34607","34608","34609","34613","34614","33510","33511","33527","33534","33547","33548","33549","33556",
  "33558","33559","33563","33565","33566","33567","33569","33570","33572","33573","33578","33579","33584","33586",
  "33592","33594","33596","33602","33603","33604","33605","33606","33607","33609","33610","33611","33612","33613",
  "33614","33615","33616","33617","33618","33619","33620","33621","33624","33625","33626","33629","33634","33635",
  "33637","33647","34201","34202","34203","34205","34207","34208","34209","34210","34211","34212","34215","34216",
  "34217","34219","34221","34222","33523","33524","33525","33537","33539","33540","33541","33542","33543","33544",
  "33545","33576","34610","34637","34638","34639","34652","34653","34654","34655","34667","34668","34669","34673",
  "34674","34679","34680","34690","34691","33701","33702","33703","33704","33705","33706","33707","33708","33709",
  "33710","33711","33712","33713","33714","33715","33716","33755","33756","33759","33760","33761","33762","33763",
  "33764","33765","33767","33770","33771","33772","33773","33774","33776","33777","33778","33781","33782","33785",
  "34677","34681","34683","34684","34685","34688","34689","33801","33803","33805","33809","33810","33811","33812",
  "33813","33815","33823","33825","33830","33834","33837","33838","33839","33841","33843","33844","33847","33849",
  "33850","33851","33853","33859","33860","33867","33868","33870","33873","33875","33876","33877","33880","33881",
  "33882","33884","33896","33898","34231","34232","34233","34234","34235","34236","34237","34238","34239","34240",
  "34241","34242","34243","34251","34275","34276","34277","34285","34286","34287","34288","34289","34292","34293",
  "34295"
))

filtered_data <- read_csv("Data/Medicare_dataset.csv", show_col_types = FALSE) %>%
# Amending mistakenly attributed ZIP codes from original dataset
  mutate(Rndrng_Prvdr_Zip5 = ifelse(Rndrng_Prvdr_Zip5 %in% c("19107", "19144"), "33308", Rndrng_Prvdr_Zip5)) %>%
  filter(grepl("^\\d+$", Rndrng_Prvdr_Zip5)) %>%
  mutate(Rndrng_Prvdr_Zip5 = as.numeric(Rndrng_Prvdr_Zip5)) %>%
# Filter by Tampa Bay ZIP codes
  filter(Rndrng_Prvdr_Zip5 %in% tampa_bay_zips) %>% 
# Rename columns to be more immediately understandable  
  rename(
    NPI = Rndrng_NPI,
    Provider_Last_Name = Rndrng_Prvdr_Last_Org_Name,
    Provider_First_Name = Rndrng_Prvdr_First_Name,
    Provider_MI = Rndrng_Prvdr_MI,
    Provider_Credentials = Rndrng_Prvdr_Crdntls,
    Entity_Code = Rndrng_Prvdr_Ent_Cd,
    Provider_Street1 = Rndrng_Prvdr_St1,
    Provider_Street2 = Rndrng_Prvdr_St2,
    Provider_City = Rndrng_Prvdr_City,
    Provider_State = Rndrng_Prvdr_State_Abrvtn,
    FIPS_Code = Rndrng_Prvdr_State_FIPS,
    Provider_Zip = Rndrng_Prvdr_Zip5,
    RUCA_Code = Rndrng_Prvdr_RUCA,
    RUCA_Description = Rndrng_Prvdr_RUCA_Desc,
    Provider_Country = Rndrng_Prvdr_Cntry,
    Provider_Type = Rndrng_Prvdr_Type,
    Medicare_Participation = Rndrng_Prvdr_Mdcr_Prtcptg_Ind,
    HCPCS_Code = HCPCS_Cd,
    HCPCS_Description = HCPCS_Desc,
    HCPCS_Drug_Indicator = HCPCS_Drug_Ind,
    Place_Of_Service = Place_Of_Srvc,
    Total_Beneficiaries = Tot_Benes,
    Total_Services = Tot_Srvcs,
    Total_Beneficiary_Service_Days = Tot_Bene_Day_Srvcs,
    Avg_Submitted_Charge = Avg_Sbmtd_Chrg,
    Avg_Medicare_Allowed = Avg_Mdcr_Alowd_Amt,
    Avg_Medicare_Payment = Avg_Mdcr_Pymt_Amt,
    Avg_Medicare_Standardized_Amt = Avg_Mdcr_Stdzd_Amt
  ) %>%
  select(-Provider_First_Name, -Provider_MI)

# Save the filtered data to a new CSV in the 'data' folder
write.csv(filtered_data, "Data/filtered_data.csv", row.names = FALSE)

# Print confirmation
print(paste("Filtered data saved to: Data/filtered_data.csv"))

```
# Load Data Once and Custom Functions
1. Read in the filtered .csv file for easier use without having to load the initial dataset.
2. Creation of a custom function for use in K-Means Clustering.
```{r, "Load Data"}
#Load the filtered data ONCE after cleaning and take care of problems of FIPS code error and zip map for k-mean map
filtered_data <- read_csv("Data/filtered_data.csv",
                          col_types = cols(FIPS_Code = col_character())) %>%
  mutate(FIPS_Code = as.numeric(gsub("[^0-9]", "", FIPS_Code)), Provider_Zip = sprintf("%05s", as.character(Provider_Zip)))


# Helper function to clean monetary columns
clean_money <- function(x) {
  as.numeric(gsub("[$,]", "", as.character(x)))
}

```

# Association Rule Mining: Christopher Reddish, Scott Young
## Model 1.

## Model 2.
The primary goal of this model is to see which bundled services are most often rendered depending on the associated NPI code.
1. Filters the data further by grouping all NPI codes and creation of a list associated with HCPCS codes.
2. Creation of association rules with low parameters to catch as much data as possible.
3. Creation of a dataframe to hold the top 100 mined rules by life.
4. Creation of a table that assigns HCPCS codes to their matching description.
5. Creation of the final Apriori dataframe.
6. Writing the mined rules to a .csv.
```{r, "Step 2"}
### Model 1: by Christopher Reddish

### Model 2: Grouping by NPI compared against HCPCS codes by Scott Young
# Grouping of service "transactions" for each NPI provider
transactions_all <- filtered_data %>%
  group_by(NPI) %>%
  summarize(items = list(unique(HCPCS_Code))) %>%
  pull(items) %>%
  as("transactions")

# Mine association rules with the following parameters
rules_all <- apriori(transactions_all, parameter = list(
  support = 0.01,
  confidence = 0.5,
  minlen = 2
))

# Converts rules into a data.frame of the top 100 by lift value
df_rules_all <- as(head(sort(rules_all, by = "lift"), 100), "data.frame")

# Create a lookup table of each HCPCS description using their HCPCS Code
desc_lookup <- filtered_data %>% select(HCPCS_Code, HCPCS_Description) %>% distinct()


# Extract NPI code pairs from the mined rules and labels with HCPCS Descriptions
df_Apriori_NPI_HCPCS_Code<- df_rules_all %>%
  mutate(
    lhs_codes = gsub("\\{(.*)\\} =>.*", "\\1", rules),
    rhs_codes = gsub(".*=> \\{(.*)\\}", "\\1", rules)
  ) %>%
  separate_rows(lhs_codes, sep = ",") %>%
  left_join(desc_lookup, by = c("lhs_codes" = "HCPCS_Code")) %>%
  rename(lhs_desc = HCPCS_Description) %>%
  separate_rows(rhs_codes, sep = ",") %>%
  left_join(desc_lookup, by = c("rhs_codes" = "HCPCS_Code")) %>%
  rename(rhs_desc = HCPCS_Description)

write.csv(df_Apriori_NPI_HCPCS_Code, "Data/df_Apriori_NPI_HCPCS_Code.csv", row.names = FALSE)
```
## Summary of findings

# K-Means Clustering: Christopher Reddish, Sneh Patel
The primary goal of this analysis is to analyze Medicare provider data using k-means clustering, assign meaningful cluster labels to providers based on cost and service volume, and visualize the geographic distribution of these clusters across ZIP codes in Florida using an interactive map.

```{r, "Step 3"}
# ---- Step 3: K-Means Clustering ----
# K-Means Clustering
df_raw <- filtered_data %>%
  mutate(
    Total_Services = as.numeric(Total_Services),
    Avg_Submitted_Charge = clean_money(Avg_Submitted_Charge),
    Avg_Medicare_Payment = clean_money(Avg_Medicare_Payment)
  ) %>%
  select(Total_Services, Avg_Submitted_Charge, Avg_Medicare_Payment) %>%
  na.omit()

stopifnot(all(sapply(df_raw, is.numeric)))

df_scaled <- scale(df_raw)
k <- min(4, nrow(unique(df_scaled)))
if (k < 2) stop("Not enough data to form clusters.")

set.seed(123)
clusters <- kmeans(df_scaled, centers = k, nstart = 25)

cluster_labels <- c(
  "1" = "Moderate Cost, High Volume",
  "2" = "Typical Providers",
  "3" = "High Cost, Low Volume",
  "4" = "Low Cost, Very High Volume"
)

results <- df_raw %>%
  mutate(
    Cluster = clusters$cluster,
    Cluster_Label = cluster_labels[as.character(Cluster)]
  )

# Mapping
zcta_shapes <- tigris::zctas(cb = TRUE, year = 2020) %>%
  rename(Zip = ZCTA5CE20) %>%
  mutate(Zip = sprintf("%05s", as.character(Zip)))

zip_cluster_data <- results %>%
  mutate(Provider_Zip = filtered_data$Provider_Zip) %>%
  group_by(Provider_Zip, Cluster_Label) %>%
  summarise(Count = n(), .groups = "drop")

zip_cluster_sf <- left_join(zcta_shapes, zip_cluster_data, by = c("Zip" = "Provider_Zip")) %>%
  filter(!is.na(Cluster_Label)) %>%
  st_make_valid() %>%
  filter(st_geometry_type(geometry) %in% c("POLYGON", "MULTIPOLYGON")) %>%
  st_transform(4326)

zip_cluster_sf <- zip_cluster_sf %>%
  mutate(
    fill_color = dplyr::recode(Cluster_Label,
      "Moderate Cost, High Volume" = "#1f78b4",
      "Typical Providers" = "#33a02c",
      "High Cost, Low Volume" = "#e31a1c",
      "Low Cost, Very High Volume" = "#ff7f00",
      .default = "#cccccc"
    ),
    opacity = scales::rescale(Count, to = c(0.4, 1))
  )

# Interactive Leaflet Map
leaflet_map <- leaflet::leaflet(zip_cluster_sf) %>%
  leaflet::addProviderTiles(leaflet::providers$CartoDB.Positron) %>%
  leaflet::addPolygons(
    fillColor = ~fill_color,
    fillOpacity = ~opacity,
    color = "#444444",
    weight = 0.5,
    popup = ~paste0(
      "<b>ZIP:</b> ", Zip, "<br>",
      "<b>Cluster:</b> ", Cluster_Label, "<br>",
      "<b>Provider Count:</b> ", Count
    )
  ) %>%
  leaflet::addLegend(
    "bottomright",
    colors = c("#1f78b4", "#33a02c", "#e31a1c", "#ff7f00"),
    labels = c(
      "Moderate Cost, High Volume",
      "Typical Providers",
      "High Cost, Low Volume",
      "Low Cost, Very High Volume"
    ),
    title = "Cluster Type",
    opacity = 1
  )

htmlwidgets::saveWidget(leaflet_map, "Output/Medicare_Clusters_FL.html", selfcontained = TRUE)

```
## Summary of Findings
According to the provider statistics, Cluster 2 is the most common, accounting for the majority of providers,
while Cluster 3 is under-represented, implying potential clustering imbalances. Cluster 2 has a wide range of values for total services, average submitted charge, and average Medicare payment, with average Medicare payments at $70.23, average submitted charges at $356.84, and an average of 604 total services; however, Cluster 3 has higher costs and lower service volumes, with average Medicare payments at $425.36, average submitted charges at $4,490.86, and an average of 29 total services. These findings indicate that the clustering technique should be reconsidered, possibly using new algorithms or feature engineering, as well as a more rigorous outlier analysis within Cluster 2 to assess whether some providers should be reclassified in order to establish more distinct and balanced groups.

# Linear Regression: Steven Barden, Scott Young
 The primary goal of this methodology is to identify and understand factors influencing average Medicare payments.
 1. Creation of a dataframe to be used within this section for linear regression/linear mixed-effects.
 2. Creation of the model that compares logarithmic Medicare payements to scaled statistics of various factors.
 3. Print of a summary of the model's findings.
 4. Creation of a dataframe that narrows down key drivers after analyzing the model's summary.
 5. Creation of a key drivers plot.
 6. Creation of a dataframe that lists each specialty.
 7. Creation of a plot that maps each specialty to their impact on Medicare payment costs.
```{r, "Step 4"}
## Linear Regression (Step 4)
# Load and clean with basic numeric conversion
df_lm <- filtered_data %>%
  select(
    Avg_Medicare_Payment,
    Total_Services,
    Avg_Submitted_Charge,
    Total_Beneficiaries,
    Place_Of_Service,
    Provider_Type,
    RUCA_Description
  ) %>%
  mutate(
    Medicare_Payment = parse_number(as.character(Avg_Medicare_Payment)),
    Services = parse_number(as.character(Total_Services)),
    Submitted_Charge = parse_number(as.character(Avg_Submitted_Charge)),
    Beneficiaries = parse_number(as.character(Total_Beneficiaries)),
    Place_Of_Service = factor(Place_Of_Service),
    Specialty = factor(Provider_Type),
    RUCA_Description = factor(RUCA_Description)
  ) %>%
  select(-Avg_Medicare_Payment, -Total_Services, -Avg_Submitted_Charge, -Total_Beneficiaries, -Provider_Type) %>%
  filter(Medicare_Payment > 1.00) %>%
  mutate(
    Log_Medicare_Payment = log(Medicare_Payment)
  ) %>%
  filter(is.finite(Log_Medicare_Payment)) %>%
  mutate(
    across(c(Services, Submitted_Charge, Beneficiaries),
           list(z = ~scale(.)),
           .names = "{.col}_z")
  ) %>%
  group_by(Specialty) %>%
  filter(n() >= 50) %>%
  ungroup %>%
  drop_na() %>%
  select(
    Log_Medicare_Payment,
    Services_z, Submitted_Charge_z, Beneficiaries_z,
    Place_Of_Service, RUCA_Description,
    Specialty
  )

# Run simplified regression (removed HCPCS_Description)
mixed_model <- lmer(
  Log_Medicare_Payment ~ Services_z + Submitted_Charge_z + Beneficiaries_z +
    Place_Of_Service + RUCA_Description +
    (1 | Specialty),
  data = df_lm,
)

# View results
summary(mixed_model)

# Key fixed effect drivers
fixed_effects <- tidy(mixed_model,
                      effects = "fixed",
                      conf.int = TRUE)

plot_data_fixed <- fixed_effects %>%
    filter(term %in% c("Submitted_Charge_z", "Place_Of_ServiceO")) %>%
  mutate(
    # Create clearer names for the plot axis
    term_cleaned = case_when(
      term == "Submitted_Charge_z" ~ "Submitted Charge Impact",
      term == "Place_Of_ServiceO" ~ "Office vs. Facility Impact",
      TRUE ~ term
    )
  )

plot_key_drivers <- ggplot(plot_data_fixed, aes(x = estimate, y = reorder(term_cleaned, estimate))) +
    geom_vline(xintercept = 0, linetype = "dashed", color = "grey70") +
    geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.15, linewidth = 0.7) +
    geom_point(size = 3.5, color = "dodgerblue") +
    labs(
      title = "Key Factors Influencing Average Medicare Payment",
      subtitle = "Estimated Impact (Positive or Negative)",
      x = "Estimated Impact on Medicare Payment",
      y = "Factor"
    ) +
    theme_minimal(base_size = 14) +
    theme(panel.grid.major.y = element_blank())

ggsave("Output/plot_key_drivers_opaque.png",
       plot = plot_key_drivers,
       width = 8,
       height = 4,
       bg = "white"
)
ggsave("Output/plot_key_drivers_transparent.png",
       plot = plot_key_drivers,
       width = 8,
       height = 4
)


# Variation between specialties
specialty_effects <- ranef(mixed_model,
                           condVar = FALSE)$Specialty %>%
  rename(Intercept_Deviation = `(Intercept)`) %>%
  tibble::rownames_to_column("Specialty")

plot_specialty_variation <- ggplot(specialty_effects, aes(x = Intercept_Deviation, y = reorder(Specialty, Intercept_Deviation))) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "grey70") +
  geom_point(size = 2, color = "forestgreen") +
  labs(
    title = "Variation in Baseline Payments Across Specialties",
    subtitle = "Deviation from Average Baseline Medicare Payment",
    x = "Estimated Deviation from Average Baseline (Medicare Payment)",
    y = "Medical Specialty"
  ) +
  theme_minimal(base_size = 14) +
  theme(
     axis.text.y = element_text(size = 8),
     panel.grid.major.y = element_blank()
  )

ggsave(
    "Output/plot_specialty_variation_opaque.png",
    plot = plot_specialty_variation,
    width = 12,
    height = 15,
    units = "in",
    dpi = 300,
    bg = "white"
)
ggsave(
    "Output/plot_specialty_variation_transparent.png",
    plot = plot_specialty_variation,
    width = 12,
    height = 15,
    units = "in",
    dpi = 300
)
```
## Summary of Findings
After analyzing 170,000 Medicare claims across the Tampa Bay area, this statistical model identifies key payment drivers. It uses a linear mixed-effects methodology that is a subset of linear regression to find differences between 76 different provider types while accounting for average charge amounts.


# Heat Map Visual: Khushi Patel, Naomi Vaid
 
```{r, "Step 5"}

# File paths
shapefile_path <- "Data/tl_2010_12_zcta510.shp"

# Load Medicare data
medicare_cleaned <- filtered_data %>%
  mutate(
    Provider_Zip = str_pad(substr(as.character(Provider_Zip), 1, 5), 5, pad = "0"),
    Avg_Medicare_Payment = as.numeric(gsub("[$,]", "", Avg_Medicare_Payment))
  )

# Load shapefile
zcta <- st_read(shapefile_path) %>%
  mutate(ZCTA5CE10 = as.character(ZCTA5CE10))

# Choose specialty
selected_specialty <- "Internal Medicine"

# Filter and summarize
hm_filtered_data <- medicare_cleaned %>%
  filter(Provider_Type == selected_specialty) %>%
  group_by(Provider_Zip) %>%
  summarize(
    Avg_Payment = mean(Avg_Medicare_Payment, na.rm = TRUE),
    Providers = n(),
    .groups = "drop"
  )

# Merge with shapefile
merged_data <- zcta %>%
  left_join(hm_filtered_data, by = c("ZCTA5CE10" = "Provider_Zip"))

# Filter with Tampa Bay ZIP codes
tampa_map_data <- merged_data %>%
  filter(ZCTA5CE10 %in% tampa_bay_zips)

# Create heat map
tampa_plot <- ggplot(data = tampa_map_data) +
  geom_sf(aes(fill = Avg_Payment), color = "white", size = 0.2) +
  scale_fill_viridis_c(
    option = "plasma",
    na.value = "grey90",
    name = "Avg Payment ($)",
    limits = c(0, 150),
    breaks = c(0, 50, 100, 150),
    oob = scales::squish
  ) +
  labs(
    title = "Medicare Average Payment by ZIP Code in Tampa Bay",
    subtitle = paste("Specialty:", selected_specialty),
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "right",
    plot.title = element_text(face = "bold", size = 16),
    plot.subtitle = element_text(size = 13),
    plot.caption = element_text(size = 10, face = "italic")
  )
# Print map
tampa_plot

# Save the heat map to the output folder
ggsave(
  filename = "Output/heatmap_transparent.png",
  plot = tampa_plot,
  width = 10,
  height = 6,
  dpi = 300
)

ggsave(
  filename = "Output/heatmap_opaque.png",
  plot = tampa_plot,
  width = 10,
  height = 6,
  dpi = 300,
  bg = "white"
)

# Here is a summary of our analysis based on Medicare payment data visualization:

# We analyzed average Medicare payments for providers specializing in Internal Medicine across Tampa Bay ZIP codes. 
# This process began by loading and preparing a cleaned Medicare dataset and a shapefile representing Florida ZIP Code Tabulation Areas (ZCTAs).

# After filtering the data for the selected specialty ("Internal Medicine"), we calculated the average Medicare 
# payment and the number of providers per ZIP code. This summarized dataset was then merged with the shapefile data 
# to enable geographic plotting.

# Using ggplot2 and the sf package, we created a choropleth map showing the distribution of average Medicare payments 
# across Tampa Bay. Areas with higher average payments appear in brighter plasma shades, while areas with lower payments 
# or no data are shown in muted tones.

# The heatmap helps reveal regional disparities in Medicare reimbursements, highlighting ZIP codes with notably higher 
# or lower average payments. These visual insights can inform further investigation into geographic trends in healthcare 
# spending, potential inequities in reimbursement rates, or gaps in provider coverage for Internal Medicine in Tampa Bay.
```
