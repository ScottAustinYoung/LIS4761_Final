---
title: "CMS Final Project"
author: Christopher Reddish, Khushi Patel, Naomi Vaid, Sneh Patel, Scott Young,  and
  Steven Barden
date: "04/20/2025"
output: html_document
---

## Introduction

```{r, "Libraries"}
# Add your library below.
# List of required packages
required_packages <- c(
  "tidyverse",
  "GGally",
  "ggplot2",
  "sf",
  "dplyr",
  "readr",
  "arules",
  "leaflet",
  "tigris",
  "scales",
  "htmlwidgets"
)

# Install any packages that are not already installed
to_install <- setdiff(required_packages, rownames(installed.packages()))
if (length(to_install) > 0) {
  install.packages(to_install, dependencies = TRUE)
}

# Load all required packages and check if successfully loaded
for (pkg in required_packages) {
  if (!require(pkg, character.only = TRUE)) {
    warning(sprintf("Package '%s' could not be loaded.", pkg))
  }
}
```

##Cleaning the dataset: Sneh Patel, Steven Barden, Christopher Reddish
1. Filtering out Florida Data
2. Adding Custom Labels for column
3. Removing unwanted columns 
```{r, "Step 1"}
## Step 1.1
# Read CSV 
filtered_data <- read_csv("Data/Medicare_dataset.csv", show_col_types = FALSE) %>%
  mutate(Rndrng_Prvdr_Zip5 = ifelse(Rndrng_Prvdr_Zip5 %in% c("19107", "19144"), "33308", Rndrng_Prvdr_Zip5)) %>%
  filter(grepl("^\\d+$", Rndrng_Prvdr_Zip5)) %>%
  mutate(Rndrng_Prvdr_Zip5 = as.numeric(Rndrng_Prvdr_Zip5)) %>%
  filter(Rndrng_Prvdr_Zip5 >= 32001 & Rndrng_Prvdr_Zip5 <= 34999) %>%
  # Rename columns
  rename(
    NPI = Rndrng_NPI,
    Provider_Last_Name = Rndrng_Prvdr_Last_Org_Name,
    Provider_First_Name = Rndrng_Prvdr_First_Name,
    Provider_MI = Rndrng_Prvdr_MI,
    Provider_Credentials = Rndrng_Prvdr_Crdntls,
    Entity_Code = Rndrng_Prvdr_Ent_Cd,
    Provider_Street1 = Rndrng_Prvdr_St1,
    Provider_Street2 = Rndrng_Prvdr_St2,
    Provider_City = Rndrng_Prvdr_City,
    Provider_State = Rndrng_Prvdr_State_Abrvtn,
    FIPS_Code = Rndrng_Prvdr_State_FIPS,
    Provider_Zip = Rndrng_Prvdr_Zip5,
    RUCA_Code = Rndrng_Prvdr_RUCA,
    RUCA_Description = Rndrng_Prvdr_RUCA_Desc,
    Provider_Country = Rndrng_Prvdr_Cntry,
    Provider_Type = Rndrng_Prvdr_Type,
    Medicare_Participation = Rndrng_Prvdr_Mdcr_Prtcptg_Ind,
    HCPCS_Code = HCPCS_Cd,
    HCPCS_Description = HCPCS_Desc,
    HCPCS_Drug_Indicator = HCPCS_Drug_Ind,
    Place_Of_Service = Place_Of_Srvc,
    Total_Beneficiaries = Tot_Benes,
    Total_Services = Tot_Srvcs,
    Total_Beneficiary_Service_Days = Tot_Bene_Day_Srvcs,
    Avg_Submitted_Charge = Avg_Sbmtd_Chrg,
    Avg_Medicare_Allowed = Avg_Mdcr_Alowd_Amt,
    Avg_Medicare_Payment = Avg_Mdcr_Pymt_Amt,
    Avg_Medicare_Standardized_Amt = Avg_Mdcr_Stdzd_Amt
  ) %>%
  # Drop unnecessary columns
  select(-Provider_First_Name, -Provider_MI)

# Save the filtered data to a new CSV in the 'data' folder
write.csv(filtered_data, "Data/filtered_data.csv", row.names = FALSE)

# Print confirmation
print(paste("Filtered data saved to: Data/filtered_data.csv"))

```
## Load Data Once and Custom Functions
```{r, "Load Data"}
# Load the filtered data ONCE after cleaning
filtered_data <- read_csv("Data/filtered_data.csv", show_col_types = FALSE)
# Helper function to clean monetary columns
clean_money <- function(x) {
  as.numeric(gsub("[$,]", "", as.character(x)))
}
```

## Association Rule Mining: Christopher Reddish, Scott Young
 
```{r, "Step 2"}
transactions_data <- filtered_data %>%
  group_by(Provider_Type, NPI) %>%
  summarize(HCPCS_Description = list(unique(HCPCS_Description)), .groups = "drop") %>%
  ungroup() %>%
  select(HCPCS_Description) %>%
  pull()
transactions <- as(transactions_data, "transactions")

rules <- apriori(transactions, parameter = list(supp = 0.01, conf = 0.5, minlen = 2))
inspect(head(sort(rules, by = "lift"), 10))
rules_df <- as(rules, "data.frame")
```


## K-Means Clustering: Christopher Reddish, Sneh Patel
# The primary goal of this analysis is to segment healthcare providers into distinct groups based on their service volume, average submitted charges, and average Medicare payment amounts to identify potential billing anomalies, promote best practices in cost-effective care, and inform targeted policy interventions within the Medicare system.

```{r, "Step 3"}



# 1. Load and clean only the necessary columns
df_raw <- filtered_data %>%
  mutate(
    Total_Services = as.numeric(`Total_Services`),
    Avg_Submitted_Charge = clean_money(`Avg_Submitted_Charge`),
    Avg_Medicare_Payment = clean_money(`Avg_Medicare_Payment`)
  ) %>%
  select(
    Total_Services,
    Avg_Submitted_Charge,
    Avg_Medicare_Payment
  ) %>%
  na.omit()

stopifnot(
  all(sapply(df_raw, is.numeric))
)

cat("Rows after cleaning:", nrow(df_raw), "\n")
cat("Unique rows:", nrow(unique(df_raw)), "\n")

# 2. Scale the data
df_scaled <- scale(df_raw)

# 3. Determine number of clusters (up to 4)
k <- min(4, nrow(unique(df_scaled)))
if (k < 2) stop("Not enough data to form clusters.")

# 4. Run k-means clustering
set.seed(123)
clusters <- kmeans(df_scaled, centers = k, nstart = 25)

# 5. Add cluster labels to the original data
results <- df_raw %>%
  mutate(Cluster = clusters$cluster)

# 6. Save results
write_csv(results, "provider_clusters.csv")

# 7. Visualize clusters (optional)
ggpairs(
  bind_cols(as_tibble(df_raw), Cluster = factor(clusters$cluster)),
  columns = 1:3,
  aes(color = Cluster)
)

# 8. Calculate summary statistics for each cluster
cluster_summary <- results %>%
    group_by(Cluster) %>%
    summarize(across(
      c(Total_Services, Avg_Submitted_Charge, Avg_Medicare_Payment),
      list(
        mean = ~mean(.x, na.rm = TRUE),
        median = ~median(.x, na.rm = TRUE)
      ),
      .names = "{.col}_{.fn}"
    ))

print(cluster_summary)


```
# Here's a summary of our analysis, based on the provided data and the cluster results:
# We performed K-means clustering on a dataset of healthcare providers to identify distinct groups based on their service volume (Total_Services), average submitted charges (Avg_Sbmtd_Chrg), and average Medicare payment amounts (Avg_Pymt_Amt). 
# This involved cleaning the data to handle currency formatting, scaling the relevant columns, and then running the K-means algorithm to group providers into clusters. Based on this, a summary of the clusters can be performed
# The clustering process revealed four distinct provider groups:
# Cluster 1: These providers exhibit a smaller average number of services (41.43), and are associated with very high average submitted charges (6860.51) and high average payment amounts (1116.04).
# Cluster 2: This is the largest group, with the vast majority of providers, and they have somewhat low average number of services (63.48) and average submitted charges (366.53), resulting in moderate average payment amounts (79.17).
# Cluster 3: The smallest group, this group is associated with a low average number of services (35.48), while incurring incredibly high average submitted charges (40919.94) with a result of very high average payment amounts (8328.96).
# Cluster 4: This cluster has the highest average number of services (515.20), while having low submitted charges (204.16), ultimately leading to low payment amounts (58.04).
# These findings offer actionable insights. Clusters 1 and 3 might warrant further investigation for potentially inflated billing practices due to their high charges despite low service volumes. 
# Conversely, Cluster 4 represents a high-volume, low-cost service model, which could be studied to identify best practices for efficient healthcare delivery. 
# Cluster 2 represents the average provider, based on this dataset. 
# These insights can inform targeted policy interventions, audits, and strategies for improving cost-effectiveness and quality of care within the Medicare system


## Linear Regression: Steven Barden, Scott Young
 
```{r, "Step 4"}
## Linear Regression (Step 4)
# Load and clean with basic numeric conversion
df_lm <- filtered_data %>%
  select(
    Avg_Medicare_Payment,
    Total_Services,
    Avg_Submitted_Charge,
    Total_Beneficiaries,
    Place_Of_Service,
    Provider_Type,
    RUCA_Description
  ) %>%
  mutate(
    Medicare_Payment = parse_number(as.character(Avg_Medicare_Payment)),
    Services = parse_number(as.character(Total_Services)),
    Submitted_Charge = parse_number(as.character(Avg_Submitted_Charge)),
    Beneficiaries = parse_number(as.character(Total_Beneficiaries)),
    Place_Of_Service = factor(Place_Of_Service),
    Specialty = factor(Provider_Type),
    RUCA_Description = factor(RUCA_Description)
  ) %>%
  select(-Avg_Medicare_Payment, -Total_Services, -Avg_Submitted_Charge, -Total_Beneficiaries, -Provider_Type) %>%
  drop_na()

# Run simplified regression (removed HCPCS_Description)
lm_model <- lm(
  Medicare_Payment ~ Services + Submitted_Charge + Beneficiaries + 
    Place_Of_Service + Specialty + RUCA_Description,
  data = df_lm
)

# View results
summary(lm_model)
```
# The linear model uses Services, Submitted_Charge, and Beneficiaries as the numeric predictors.
# The categorical predictors are Place_Of_Srvc, Specialty, and RUCA_Desc.
# The R-squared value of the model is 0.6486, which explains a 65%~ variation in Medicare_Payment.
# The F-statistic & P-values are both quite high, indicating a statistically significant model.
# The average error stands at about $176.
# As the Services increase, the average Medicare_Payment slightly decreases which tells that dense facilities reflect an economy-of-scale factor.
# The strongest predictor is the Submitted_Charge value, in which higher billed values raises Medicare payments, as is obvious.
# Beneficiaries stands as not significant, meaning the amount of people receiving service does not influence costs.
# Place_Of_Srvc0, in an office setting, has a high p-value of $20.20. This stands to reason that smaller facilities are associated with a higher cost.
# In terms of other categorical variables and their effect, Specialty has a range of types in which costs are reduced or increased on average.
## Increases include: Ambulance Service Provider, Oral Surgery, Peripheral Vascular Disease, and Micrographic Dermatologic Surgery.
## Decreases include: CRN and Anesthesiology.
# RUCA_Desc has the following takeaways: Micropolitan areas receive less payment, Secondary flow to large urbanized areas has a higher payment.

## Heat Map Visual: Khushi Patel, Naomi Vaid
 
```{r, "Step 5"}

# File paths
shapefile_path <- "~/Data/tl_2010_12_zcta510.shp"

# Load Medicare data
medicare_cleaned <- filtered_data %>%
  mutate(
    Provider_Zip = as.character(Provider_Zip),
    Avg_Medicare_Payment = as.numeric(gsub("[$,]", "", Avg_Medicare_Payment))
  )

# Load shapefile
zcta <- st_read(shapefile_path) %>%
  mutate(ZCTA5CE10 = as.character(ZCTA5CE10))

# Choose specialty
selected_specialty <- "Internal Medicine"

# Filter and summarize
filtered_data <- medicare_cleaned %>%
  filter(Specialty == selected_specialty) %>%
  group_by(Provider_Zip) %>%
  summarize(
    Avg_Payment = mean(Avg_Medicare_Payment, na.rm = TRUE),
    Providers = n(),
    .groups = "drop"
  )

# Merge with shapefile
merged_data <- zcta %>%
  left_join(filtered_data, by = c("ZCTA5CE10" = "Provider_Zip"))

# Create heat map
ggplot(data = merged_data) +
  geom_sf(aes(fill = Avg_Payment), color = "white", size = 0.2) +
  scale_fill_viridis_c(
    option = "plasma",
    na.value = "grey90",
    name = "Avg Payment ($)",
    limits = c(0, 150),
    breaks = c(0, 50, 100, 150),
    oob = scales::squish
  ) +
  labs(
    title = "Medicare Average Payment by ZIP Code in Florida",
    subtitle = paste("Specialty:", selected_specialty),
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "right",
    plot.title = element_text(face = "bold", size = 16),
    plot.subtitle = element_text(size = 13),
    plot.caption = element_text(size = 10, face = "italic")
  )

# Here is a summary of our analysis based on Medicare payment data visualization:

# We analyzed average Medicare payments for providers specializing in Internal Medicine across Florida ZIP codes. 
# This process began by loading and preparing a cleaned Medicare dataset and a shapefile representing Florida ZIP Code Tabulation Areas (ZCTAs).

# After filtering the data for the selected specialty ("Internal Medicine"), we calculated the average Medicare 
# payment and the number of providers per ZIP code. This summarized dataset was then merged with the shapefile data 
# to enable geographic plotting.

# Using ggplot2 and the sf package, we created a choropleth map showing the distribution of average Medicare payments 
# across Florida. Areas with higher average payments appear in brighter plasma shades, while areas with lower payments 
# or no data are shown in muted tones.

# The heatmap helps reveal regional disparities in Medicare reimbursements, highlighting ZIP codes with notably higher 
# or lower average payments. These visual insights can inform further investigation into geographic trends in healthcare 
# spending, potential inequities in reimbursement rates, or gaps in provider coverage for Internal Medicine in Florida.
```
